<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pixel Art AI Studio - Atalhos</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overscroll-behavior: none;
        }
        .tool-button.active, .layer-item.active-layer {
            background-color: #4A5568; /* bg-gray-700 */
            color: white;
        }
        .frame-thumbnail {
            border: 1px solid #CBD5E0; /* border-gray-400 */
            cursor: pointer;
            width: 64px;
            height: 64px;
            object-fit: contain;
            background-color: white;
            image-rendering: pixelated;
        }
        .frame-thumbnail.active-frame {
            border-color: #2B6CB0; /* border-blue-600 */
            border-width: 2px;
            box-shadow: 0 0 0 2px #2B6CB0;
        }
        #pixelCanvas {
            cursor: crosshair;
            background-color: #F0F0F0; 
            background-image: 
                linear-gradient(45deg, #ccc 25%, transparent 25%), 
                linear-gradient(-45deg, #ccc 25%, transparent 25%),
                linear-gradient(45deg, transparent 75%, #ccc 75%),
                linear-gradient(-45deg, transparent 75%, #ccc 75%);
            background-size: 20px 20px; 
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
            image-rendering: pixelated;
            border: 1px solid #4A5568; 
        }
        .modal {
            display: none; 
            position: fixed;
            z-index: 100;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.5);
            align-items: center; 
            justify-content: center;
        }
        .modal-content {
            background-color: #fefefe;
            padding: 20px;
            border: 1px solid #888;
            width: 80%;
            max-width: 500px;
            border-radius: 8px;
        }
        .color-palette-item {
            width: 24px;
            height: 24px;
            border-radius: 4px;
            cursor: pointer;
            border: 1px solid #ccc;
            transition: transform 0.1s ease;
        }
        .color-palette-item:hover {
            transform: scale(1.1);
        }
        #canvasContainer {
            width: fit-content;
            height: fit-content;
            overflow: auto; 
            max-width: 100%;
            margin: auto;
            position: relative; /* Para o canvas de overlay da seleção */
        }
        #selectionCanvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none; /* Para que os cliques passem para o canvas principal */
            image-rendering: pixelated;
        }
        .layer-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 6px 8px;
            border-radius: 4px;
            margin-bottom: 4px;
            cursor: pointer;
            background-color: #718096; 
            border: 1px solid #4A5568; 
        }
        .layer-item:hover {
            background-color: #4A5568; 
        }
        .layer-name {
            flex-grow: 1;
            margin-left: 8px;
            font-size: 0.875rem;
        }
        .layer-actions button {
            background: none;
            border: none;
            color: #E2E8F0; 
            margin-left: 5px;
            cursor: pointer;
        }
         .layer-actions button:hover {
            color: white;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800 flex flex-col md:flex-row h-screen overflow-hidden">

    <!-- Painel de Ferramentas Esquerdo -->
    <aside class="w-full md:w-72 bg-gray-800 text-white p-4 space-y-6 overflow-y-auto">
        <div>
            <h2 class="text-xl font-semibold mb-3">Pixel Art AI Studio</h2>
        </div>

        <!-- Configurações do Canvas -->
        <div class="space-y-2">
            <h3 class="text-lg font-medium">Canvas</h3>
            <div class="flex items-center space-x-2">
                <label for="canvasWidth" class="text-sm">Largura:</label>
                <input type="number" id="canvasWidth" value="32" class="w-16 p-1 rounded bg-gray-700 text-white text-sm">
                <span class="text-sm">px</span>
            </div>
            <div class="flex items-center space-x-2">
                <label for="canvasHeight" class="text-sm">Altura:</label>
                <input type="number" id="canvasHeight" value="32" class="w-16 p-1 rounded bg-gray-700 text-white text-sm">
                <span class="text-sm">px</span>
            </div>
             <div class="flex items-center space-x-2">
                <label for="pixelSize" class="text-sm">Zoom Edição:</label>
                <input type="range" id="pixelSize" min="5" max="40" value="20" class="w-full">
                <span id="pixelSizeValue" class="text-sm w-8 text-right">20px</span>
            </div>
            <button id="resizeCanvas" class="w-full bg-blue-500 hover:bg-blue-600 text-white py-2 px-3 rounded-md text-sm transition duration-150">Aplicar Tamanho</button>
            <div class="flex items-center space-x-2 mt-2">
                <input type="checkbox" id="showGrid" checked class="rounded text-blue-500 focus:ring-blue-500">
                <label for="showGrid" class="text-sm">Mostrar Grade</label>
            </div>
        </div>

        <!-- Ferramentas -->
        <div class="space-y-2">
            <h3 class="text-lg font-medium">Ferramentas</h3>
            <button id="pencilTool" class="tool-button w-full text-left bg-gray-700 hover:bg-gray-600 py-2 px-3 rounded-md text-sm transition duration-150 active">✏️ Pincel (B)</button>
            <button id="eraserTool" class="tool-button w-full text-left bg-gray-700 hover:bg-gray-600 py-2 px-3 rounded-md text-sm transition duration-150"><i class="fas fa-eraser"></i> Borracha (E)</button>
            <button id="fillTool" class="tool-button w-full text-left bg-gray-700 hover:bg-gray-600 py-2 px-3 rounded-md text-sm transition duration-150"><i class="fas fa-fill-drip"></i> Balde de Tinta (G)</button>
            <button id="eyedropperTool" class="tool-button w-full text-left bg-gray-700 hover:bg-gray-600 py-2 px-3 rounded-md text-sm transition duration-150"><i class="fas fa-eye-dropper"></i> Conta-gotas (I)</button>
            <button id="selectionTool" class="tool-button w-full text-left bg-gray-700 hover:bg-gray-600 py-2 px-3 rounded-md text-sm transition duration-150"><i class="fas fa-vector-square"></i> Seleção (M)</button>
            <button id="moveTool" class="tool-button w-full text-left bg-gray-700 hover:bg-gray-600 py-2 px-3 rounded-md text-sm transition duration-150"><i class="fas fa-arrows-alt"></i> Mover (V)</button>
            <button id="rotateTool" class="tool-button w-full text-left bg-gray-700 hover:bg-gray-600 py-2 px-3 rounded-md text-sm transition duration-150 opacity-50 cursor-not-allowed" title="Rotação (Em breve)"><i class="fas fa-sync-alt"></i> Rotacionar</button>
        </div>
         <div id="selectionActions" class="space-y-2 mt-2 hidden"> 
            <h4 class="text-md font-medium">Ações da Seleção</h4>
            <button id="commitSelection" class="w-full bg-green-500 hover:bg-green-600 text-white py-1 px-2 rounded-md text-xs">Confirmar Seleção (Enter)</button>
            <button id="cancelSelection" class="w-full bg-red-500 hover:bg-red-600 text-white py-1 px-2 rounded-md text-xs mt-1">Cancelar Seleção (Esc)</button>
             <div class="flex space-x-1 mt-1">
                <button id="rotateSelectionCW" class="flex-1 bg-indigo-500 hover:bg-indigo-600 text-white py-1 px-2 rounded-md text-xs"><i class="fas fa-rotate-right"></i> 90°</button>
                <button id="rotateSelectionCCW" class="flex-1 bg-indigo-500 hover:bg-indigo-600 text-white py-1 px-2 rounded-md text-xs"><i class="fas fa-rotate-left"></i> -90°</button>
            </div>
        </div>


        <!-- Cores -->
        <div class="space-y-2">
            <h3 class="text-lg font-medium">Cor</h3>
            <input type="color" id="colorPicker" value="#000000" class="w-full h-10 p-0 border-none rounded cursor-pointer">
            <div id="colorPalette" class="grid grid-cols-8 gap-1 mt-2"></div>
            <button id="clearLayer" class="w-full bg-red-500 hover:bg-red-600 text-white py-2 px-3 rounded-md text-sm transition duration-150 mt-2">Limpar Camada Ativa</button>
        </div>
        
        <!-- Histórico -->
        <div class="space-y-2">
            <h3 class="text-lg font-medium">Histórico</h3>
            <button id="undoButton" class="w-full bg-yellow-500 hover:bg-yellow-600 text-black py-2 px-3 rounded-md text-sm transition duration-150">Desfazer (Ctrl+Z)</button>
        </div>

        <!-- Exportar -->
        <div class="space-y-2">
            <h3 class="text-lg font-medium">Exportar</h3>
            <div class="flex items-center space-x-2">
                <label for="exportZoom" class="text-sm">Zoom Export:</label>
                <input type="number" id="exportZoom" value="10" min="1" max="100" class="w-16 p-1 rounded bg-gray-700 text-white text-sm">
                <span class="text-sm">x (1000%)</span>
            </div>
            <button id="exportPNG" class="w-full bg-green-500 hover:bg-green-600 text-white py-2 px-3 rounded-md text-sm transition duration-150">Exportar PNG</button>
            <button id="exportJPG" class="w-full bg-teal-500 hover:bg-teal-600 text-white py-2 px-3 rounded-md text-sm transition duration-150">Exportar JPG</button>
        </div>
        
        <div class="space-y-2 opacity-50">
            <h3 class="text-lg font-medium">Recursos IA (Em Breve)</h3>
            <button class="w-full bg-purple-500 text-white py-2 px-3 rounded-md text-sm cursor-not-allowed">Gerar de Imagem</button>
            <button class="w-full bg-indigo-500 text-white py-2 px-3 rounded-md text-sm cursor-not-allowed">Animar com IA</button>
        </div>
    </aside>

    <!-- Área Principal do Canvas -->
    <main class="flex-1 flex flex-col items-center justify-center p-4 overflow-auto bg-gray-200">
        <div id="canvasContainer" class="shadow-lg">
            <canvas id="pixelCanvas"></canvas>
            <canvas id="selectionCanvas"></canvas> 
        </div>
    </main>

    <!-- Painel Direito (Animação e Camadas) -->
    <aside class="w-full md:w-80 bg-gray-800 text-white p-4 flex flex-col space-y-4 overflow-y-auto">
        <!-- Camadas -->
        <div class="flex-shrink-0">
            <h3 class="text-lg font-medium mb-2">Camadas</h3>
            <div id="layersContainer" class="bg-gray-700 p-2 rounded-md space-y-1 max-h-60 overflow-y-auto mb-2">
            </div>
            <div class="grid grid-cols-3 gap-2">
                <button id="addLayer" class="bg-green-500 hover:bg-green-600 py-1 px-2 rounded-md text-xs transition duration-150"><i class="fas fa-plus-square"></i> Nova</button>
                <button id="removeLayer" class="bg-red-500 hover:bg-red-600 py-1 px-2 rounded-md text-xs transition duration-150"><i class="fas fa-trash-alt"></i> Remover</button>
                <button id="duplicateLayer" class="bg-yellow-500 hover:bg-yellow-600 text-black py-1 px-2 rounded-md text-xs transition duration-150"><i class="fas fa-clone"></i> Duplicar</button>
            </div>
             <div class="flex space-x-2 mt-2">
                <button id="moveLayerUp" class="flex-1 bg-blue-500 hover:bg-blue-600 py-1 px-2 rounded-md text-xs transition duration-150"><i class="fas fa-arrow-up"></i> Subir</button>
                <button id="moveLayerDown" class="flex-1 bg-blue-500 hover:bg-blue-600 py-1 px-2 rounded-md text-xs transition duration-150"><i class="fas fa-arrow-down"></i> Descer</button>
            </div>
        </div>

        <!-- Animação -->
        <div class="flex-shrink-0">
            <h3 class="text-lg font-medium mt-4 mb-2">Animação</h3>
            <div class="grid grid-cols-3 gap-2">
                <button id="addFrame" class="bg-blue-500 hover:bg-blue-600 py-2 px-3 rounded-md text-sm transition duration-150">Adicionar</button>
                <button id="removeFrame" class="bg-red-500 hover:bg-red-600 py-2 px-3 rounded-md text-sm transition duration-150">Remover</button>
                <button id="duplicateFrame" class="bg-yellow-500 hover:bg-yellow-600 text-black py-2 px-3 rounded-md text-sm transition duration-150"><i class="fas fa-copy"></i> Duplicar</button>
            </div>
            <div id="framesContainer" class="flex flex-wrap gap-2 bg-gray-700 p-2 rounded-md min-h-[80px] mt-2"></div>
            <div class="space-y-2 mt-2">
                <label for="fpsSlider" class="text-sm">FPS: <span id="fpsValue">10</span></label>
                <input type="range" id="fpsSlider" min="1" max="30" value="10" class="w-full">
            </div>
            <button id="playAnimation" class="w-full bg-green-500 hover:bg-green-600 py-2 px-3 rounded-md text-sm transition duration-150 mt-2">Play</button>
            <div class="mt-2 bg-gray-700 p-1 rounded-md flex items-center justify-center" style="min-height: 128px;">
                <canvas id="animationPreview" class="border border-gray-500" style="image-rendering: pixelated;"></canvas>
            </div>
        </div>
    </aside>

    <!-- Modal para mensagens -->
    <div id="messageModal" class="modal">
        <div class="modal-content bg-white dark:bg-gray-800 p-6 rounded-lg shadow-xl">
            <p id="modalMessageText" class="text-gray-800 dark:text-gray-200"></p>
            <div class="flex justify-end mt-4">
                <button id="modalConfirmButton" class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded mr-2 hidden">Confirmar</button>
                <button id="modalCloseButton" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded">OK</button>
            </div>
        </div>
    </div>

    <script>
        // Elementos da UI
        const canvas = document.getElementById('pixelCanvas');
        const ctx = canvas.getContext('2d');
        const selectionCanvas = document.getElementById('selectionCanvas'); 
        const selectionCtx = selectionCanvas.getContext('2d');
        const canvasContainer = document.getElementById('canvasContainer');
        const canvasWidthInput = document.getElementById('canvasWidth');
        const canvasHeightInput = document.getElementById('canvasHeight');
        const pixelSizeSlider = document.getElementById('pixelSize');
        const pixelSizeValue = document.getElementById('pixelSizeValue');
        const resizeCanvasButton = document.getElementById('resizeCanvas');
        const showGridCheckbox = document.getElementById('showGrid');
        
        const pencilToolButton = document.getElementById('pencilTool');
        const eraserToolButton = document.getElementById('eraserTool');
        const fillToolButton = document.getElementById('fillTool');
        const eyedropperToolButton = document.getElementById('eyedropperTool');
        const selectionToolButton = document.getElementById('selectionTool');
        const moveToolButton = document.getElementById('moveTool');
        const rotateToolButton = document.getElementById('rotateTool'); 

        const selectionActionsPanel = document.getElementById('selectionActions');
        const commitSelectionButton = document.getElementById('commitSelection');
        const cancelSelectionButton = document.getElementById('cancelSelection');
        const rotateSelectionCWButton = document.getElementById('rotateSelectionCW');
        const rotateSelectionCCWButton = document.getElementById('rotateSelectionCCW');

        const colorPicker = document.getElementById('colorPicker');
        const clearLayerButton = document.getElementById('clearLayer'); 
        const undoButton = document.getElementById('undoButton');

        const exportZoomInput = document.getElementById('exportZoom');
        const exportPNGButton = document.getElementById('exportPNG');
        const exportJPGButton = document.getElementById('exportJPG');

        const layersContainer = document.getElementById('layersContainer');
        const addLayerButton = document.getElementById('addLayer');
        const removeLayerButton = document.getElementById('removeLayer');
        const duplicateLayerButton = document.getElementById('duplicateLayer');
        const moveLayerUpButton = document.getElementById('moveLayerUp');
        const moveLayerDownButton = document.getElementById('moveLayerDown');

        const addFrameButton = document.getElementById('addFrame');
        const removeFrameButton = document.getElementById('removeFrame');
        const duplicateFrameButton = document.getElementById('duplicateFrame');
        const framesContainer = document.getElementById('framesContainer');
        const fpsSlider = document.getElementById('fpsSlider');
        const fpsValue = document.getElementById('fpsValue');
        const playAnimationButton = document.getElementById('playAnimation');
        const animationPreviewCanvas = document.getElementById('animationPreview');
        const animationPreviewCtx = animationPreviewCanvas.getContext('2d');

        const messageModal = document.getElementById('messageModal');
        const modalMessageText = document.getElementById('modalMessageText');
        const modalCloseButton = document.getElementById('modalCloseButton');
        const modalConfirmButton = document.getElementById('modalConfirmButton');
        let modalConfirmCallback = null;

        // Estado da Aplicação
        let canvasWidth = parseInt(canvasWidthInput.value);
        let canvasHeight = parseInt(canvasHeightInput.value);
        let pixelSize = parseInt(pixelSizeSlider.value); 
        let showGrid = showGridCheckbox.checked;
        let currentColor = colorPicker.value;
        let currentTool = 'pencil'; 
        let isDrawing = false; 
        
        let frames = [];
        let currentFrameIndex = -1;
        let currentLayerIndex = -1; 

        let animationInterval;
        let isPlaying = false;

        // Estado da Seleção
        let selectionRect = null; 
        let isSelecting = false; 
        let selectedImageData = null; 
        let floatingSelection = null; 
        let selectionDragStart = null; 

        const defaultPalette = [
            '#000000', '#FFFFFF', '#FF0000', '#00FF00', '#0000FF', '#FFFF00', '#00FFFF', '#FF00FF',
            '#808080', '#C0C0C0', '#800000', '#008000', '#000080', '#808000', '#008080', '#800080',
            '#FFA500', '#A52A2A', '#8A2BE2', '#5F9EA0', '#D2691E', '#FF7F50', '#6495ED', '#DC143C'
        ];

        // --- Funções do Modal ---
        function showModal(message, showConfirm = false, callback = null) {
            modalMessageText.textContent = message;
            modalConfirmButton.style.display = showConfirm ? 'block' : 'none';
            modalConfirmCallback = callback;
            messageModal.style.display = 'flex';
        }
        modalCloseButton.onclick = () => {
            messageModal.style.display = 'none';
            modalConfirmCallback = null;
        }
        modalConfirmButton.onclick = () => {
            if (modalConfirmCallback) {
                modalConfirmCallback();
            }
            messageModal.style.display = 'none';
            modalConfirmCallback = null;
        }

        // --- Inicialização ---
        function initialize() {
            setupInitialCanvasState(); 
            addEventListeners();
            addNewFrame(); 
            updateToolButtons();
            populateColorPalette();
            updatePixelSizeDisplay();
            setupSelectionCanvas();
        }
        
        function setupInitialCanvasState() {
            canvas.width = canvasWidth * pixelSize;
            canvas.height = canvasHeight * pixelSize;
            selectionCanvas.width = canvasWidth * pixelSize; 
            selectionCanvas.height = canvasHeight * pixelSize;
            animationPreviewCanvas.width = canvasWidth * 4; 
            animationPreviewCanvas.height = canvasHeight * 4;
            animationPreviewCtx.imageSmoothingEnabled = false;
            ctx.imageSmoothingEnabled = false;
            selectionCtx.imageSmoothingEnabled = false;
        }

        function setupSelectionCanvas() {
            selectionCanvas.width = canvasWidth * pixelSize;
            selectionCanvas.height = canvasHeight * pixelSize;
            selectionCtx.imageSmoothingEnabled = false;
            selectionCtx.lineWidth = 1;
            selectionCtx.setLineDash([3, 3]); 
        }

        function populateColorPalette() {
            const paletteContainer = document.getElementById('colorPalette');
            paletteContainer.innerHTML = '';
            defaultPalette.forEach(color => {
                const colorDiv = document.createElement('div');
                colorDiv.className = 'color-palette-item';
                colorDiv.style.backgroundColor = color;
                colorDiv.addEventListener('click', () => {
                    colorPicker.value = color;
                    currentColor = color;
                });
                paletteContainer.appendChild(colorDiv);
            });
        }

        function createEmptyLayerData(nameSuffix = "") {
            const layerPixelData = new Uint8ClampedArray(canvasWidth * canvasHeight * 4);
            for (let i = 0; i < layerPixelData.length; i += 4) {
                layerPixelData[i+3] = 0; // Transparente
            }
            // Ajuste para nomear corretamente ao criar a primeira camada de um novo frame
            let layerNumber = 1;
            if (frames[currentFrameIndex] && frames[currentFrameIndex].layers) {
                layerNumber = frames[currentFrameIndex].layers.length + 1;
            } else if (frames.length > 0 && frames[frames.length-1] && frames[frames.length-1].layers) {
                 // Caso especial para addNewFrame antes de currentFrameIndex ser totalmente definido
                 layerNumber = frames[frames.length-1].layers.length +1;
            }


            const baseName = `Camada ${layerNumber}`;
            return { 
                imageData: new ImageData(layerPixelData, canvasWidth, canvasHeight),
                name: `${baseName}${nameSuffix}`,
                visible: true,
                history: [] 
            };
        }
        
        function clearActiveLayerContent() {
            if (currentFrameIndex === -1 || currentLayerIndex === -1) return;
            showModal("Tem certeza que deseja limpar a camada ativa?", true, () => {
                const activeLayer = frames[currentFrameIndex].layers[currentLayerIndex];
                const layerPixelData = activeLayer.imageData.data;
                for (let i = 0; i < layerPixelData.length; i += 4) {
                    layerPixelData[i] = 0; layerPixelData[i+1] = 0; layerPixelData[i+2] = 0; layerPixelData[i+3] = 0;
                }
                saveLayerHistory();
                redrawCurrentFrameComposed();
                updateFrameThumbnail(currentFrameIndex);
            });
        }

        function drawGrid() {
            if (!showGrid || pixelSize < 4) return;
            const visualCtx = canvas.getContext('2d'); 
            visualCtx.strokeStyle = 'rgba(0,0,0,0.1)';
            visualCtx.lineWidth = 1;
            visualCtx.setLineDash([]); 

            for (let x = 0; x <= canvas.width; x += pixelSize) {
                visualCtx.beginPath();
                visualCtx.moveTo(x, 0);
                visualCtx.lineTo(x, canvas.height);
                visualCtx.stroke();
            }
            for (let y = 0; y <= canvas.height; y += pixelSize) {
                visualCtx.beginPath();
                visualCtx.moveTo(0, y);
                visualCtx.lineTo(canvas.width, y);
                visualCtx.stroke();
            }
        }

        function redrawCurrentFrameComposed() {
            const visualCtx = canvas.getContext('2d');
            visualCtx.clearRect(0, 0, canvas.width, canvas.height); 

            if (currentFrameIndex === -1 || !frames[currentFrameIndex]) {
                drawGrid(); 
                return;
            }

            const currentFrame = frames[currentFrameIndex];
            const tempRenderCanvas = document.createElement('canvas');
            tempRenderCanvas.width = canvasWidth;
            tempRenderCanvas.height = canvasHeight;
            const tempRenderCtx = tempRenderCanvas.getContext('2d');
            tempRenderCtx.imageSmoothingEnabled = false;

            currentFrame.layers.forEach(layer => {
                if (layer.visible && layer.imageData) {
                    if (floatingSelection && layer === currentFrame.layers[currentLayerIndex] && selectionRect) {
                        const originalContentCanvas = createCanvasFromImageData(layer.imageData);
                        tempRenderCtx.drawImage(originalContentCanvas, 0, 0);
                    } else {
                        tempRenderCtx.drawImage(createCanvasFromImageData(layer.imageData), 0, 0);
                    }
                }
            });
            
            visualCtx.imageSmoothingEnabled = false;
            visualCtx.drawImage(tempRenderCanvas, 0, 0, canvasWidth, canvasHeight, 0, 0, canvas.width, canvas.height);
            
            if (floatingSelection && floatingSelection.imageData) {
                const selImgCanvas = createCanvasFromImageData(floatingSelection.imageData);
                visualCtx.drawImage(
                    selImgCanvas,
                    floatingSelection.x * pixelSize,
                    floatingSelection.y * pixelSize,
                    floatingSelection.imageData.width * pixelSize,
                    floatingSelection.imageData.height * pixelSize
                );
            }
            drawGrid();
            drawSelectionOutline(); 
        }

        function drawSelectionOutline() {
            selectionCtx.clearRect(0, 0, selectionCanvas.width, selectionCanvas.height);
            if (!selectionRect && !floatingSelection) return;

            let rectToDraw;
            if (floatingSelection) {
                rectToDraw = {
                    x: floatingSelection.x,
                    y: floatingSelection.y,
                    width: floatingSelection.imageData.width,
                    height: floatingSelection.imageData.height,
                };
            } else if (selectionRect) {
                rectToDraw = selectionRect;
            }

            if (rectToDraw) {
                selectionCtx.strokeStyle = 'rgba(0, 0, 0, 1)'; 
                selectionCtx.strokeRect(
                    rectToDraw.x * pixelSize + 0.5, 
                    rectToDraw.y * pixelSize + 0.5,
                    rectToDraw.width * pixelSize,
                    rectToDraw.height * pixelSize
                );
            }
        }

        function createCanvasFromImageData(imageData) {
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = imageData.width;
            tempCanvas.height = imageData.height;
            tempCanvas.getContext('2d').putImageData(imageData, 0, 0);
            return tempCanvas;
        }
        
        function addEventListeners() {
            resizeCanvasButton.addEventListener('click', handleResizeCanvas);
            showGridCheckbox.addEventListener('change', (e) => {
                showGrid = e.target.checked;
                redrawCurrentFrameComposed();
            });
            pixelSizeSlider.addEventListener('input', handlePixelSizeChange);

            pencilToolButton.addEventListener('click', () => setCurrentTool('pencil'));
            eraserToolButton.addEventListener('click', () => setCurrentTool('eraser'));
            fillToolButton.addEventListener('click', () => setCurrentTool('fill'));
            eyedropperToolButton.addEventListener('click', () => setCurrentTool('eyedropper'));
            selectionToolButton.addEventListener('click', () => setCurrentTool('selection'));
            moveToolButton.addEventListener('click', () => setCurrentTool('move'));

            commitSelectionButton.addEventListener('click', commitFloatingSelection);
            cancelSelectionButton.addEventListener('click', cancelActiveSelection);
            rotateSelectionCWButton.addEventListener('click', () => rotateFloatingSelection(90));
            rotateSelectionCCWButton.addEventListener('click', () => rotateFloatingSelection(-90));

            colorPicker.addEventListener('input', (e) => currentColor = e.target.value);
            clearLayerButton.addEventListener('click', clearActiveLayerContent);
            
            undoButton.addEventListener('click', undoLastActionOnLayer);
            
            // Listener de Teclado para Atalhos
            document.addEventListener('keydown', (e) => {
                // Ignora atalhos se um campo de input estiver focado
                const activeElement = document.activeElement;
                if (activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA')) {
                    if (e.key === 'Escape' && (floatingSelection || selectionRect)) { // Permite Esc para cancelar seleção mesmo em input
                         cancelActiveSelection();
                    } else if (e.key === 'Enter' && floatingSelection && activeElement !== commitSelectionButton && activeElement !== cancelSelectionButton) {
                        // Permite Enter para confirmar seleção se não for nos botões de ação da seleção
                        commitFloatingSelection();
                    }
                    return; 
                }


                if (e.ctrlKey && (e.key === 'z' || e.key === 'Z')) {
                    e.preventDefault();
                    undoLastActionOnLayer();
                } else if (e.key === 'Escape') {
                    if (floatingSelection || selectionRect) {
                        cancelActiveSelection();
                    }
                } else if (e.key === 'Enter' || e.key === 'Return') {
                    if (floatingSelection) {
                        commitFloatingSelection();
                    }
                } else {
                    // Atalhos das ferramentas
                    switch (e.key.toLowerCase()) {
                        case 'b': setCurrentTool('pencil'); break;
                        case 'e': setCurrentTool('eraser'); break;
                        case 'm': setCurrentTool('selection'); break;
                        case 'v': setCurrentTool('move'); break;
                        case 'g': setCurrentTool('fill'); break;
                        case 'i': setCurrentTool('eyedropper'); break;
                    }
                }
            });


            canvas.addEventListener('mousedown', handleCanvasMouseDown);
            canvas.addEventListener('mousemove', handleCanvasMouseMove);
            canvas.addEventListener('mouseup', handleCanvasMouseUp);
            canvas.addEventListener('mouseleave', handleCanvasMouseLeave); 
            canvas.addEventListener('contextmenu', (e) => e.preventDefault());

            exportPNGButton.addEventListener('click', () => exportImage('png'));
            exportJPGButton.addEventListener('click', () => exportImage('jpeg'));

            addLayerButton.addEventListener('click', addNewLayerToCurrentFrame);
            removeLayerButton.addEventListener('click', removeActiveLayer);
            duplicateLayerButton.addEventListener('click', duplicateActiveLayer); 
            moveLayerUpButton.addEventListener('click', () => moveActiveLayer('up'));
            moveLayerDownButton.addEventListener('click', () => moveActiveLayer('down'));

            addFrameButton.addEventListener('click', addNewFrame);
            removeFrameButton.addEventListener('click', removeCurrentFrame);
            duplicateFrameButton.addEventListener('click', duplicateActiveFrame); 
            playAnimationButton.addEventListener('click', toggleAnimation);
            fpsSlider.addEventListener('input', (e) => {
                fpsValue.textContent = e.target.value;
                if (isPlaying) { 
                    stopAnimationLoop();
                    startAnimationLoop();
                }
            });
        }
        
        function updatePixelSizeDisplay() {
            pixelSizeValue.textContent = `${pixelSize}px`;
        }

        function handlePixelSizeChange(e) {
            pixelSize = parseInt(e.target.value);
            updatePixelSizeDisplay();
            canvas.width = canvasWidth * pixelSize;
            canvas.height = canvasHeight * pixelSize;
            selectionCanvas.width = canvasWidth * pixelSize; 
            selectionCanvas.height = canvasHeight * pixelSize;
            setupSelectionCanvas(); 
            redrawCurrentFrameComposed();
        }

        function handleResizeCanvas() {
            const newWidth = parseInt(canvasWidthInput.value);
            const newHeight = parseInt(canvasHeightInput.value);

            if (isNaN(newWidth) || isNaN(newHeight) || newWidth <= 0 || newHeight <= 0) {
                showModal("Dimensões do canvas inválidas.");
                return;
            }
            if (floatingSelection) commitFloatingSelection(); 

            canvasWidth = newWidth;
            canvasHeight = newHeight;
            
            frames.forEach(frame => {
                frame.layers.forEach(layer => {
                    const oldLayerImageData = layer.imageData;
                    const newLayerPixelData = new Uint8ClampedArray(canvasWidth * canvasHeight * 4); 
                    const newLayerImageData = new ImageData(newLayerPixelData, canvasWidth, canvasHeight);
                    const tempOldCanvas = createCanvasFromImageData(oldLayerImageData);
                    const tempNewCtx = document.createElement('canvas').getContext('2d');
                    tempNewCtx.canvas.width = canvasWidth;
                    tempNewCtx.canvas.height = canvasHeight;
                    const offsetX = Math.max(0, Math.floor((canvasWidth - oldLayerImageData.width) / 2));
                    const offsetY = Math.max(0, Math.floor((canvasHeight - oldLayerImageData.height) / 2));
                    const drawWidth = Math.min(oldLayerImageData.width, canvasWidth - offsetX);
                    const drawHeight = Math.min(oldLayerImageData.height, canvasHeight - offsetY);
                    if (drawWidth > 0 && drawHeight > 0) {
                         tempNewCtx.drawImage(tempOldCanvas, 0, 0, oldLayerImageData.width, oldLayerImageData.height, offsetX, offsetY, drawWidth, drawHeight);
                    }
                    layer.imageData = tempNewCtx.getImageData(0, 0, canvasWidth, canvasHeight);
                    layer.history = []; 
                });
                if (frame.frameHistory) frame.frameHistory = [];
            });

            setupInitialCanvasState(); 
            setupSelectionCanvas();
            redrawCurrentFrameComposed();
            if (currentFrameIndex !== -1 && currentLayerIndex !== -1) saveLayerHistory(); 
            updateAllFrameThumbnails();
            updateAnimationPreviewCanvasSize();
        }
        
        function updateAnimationPreviewCanvasSize() {
            animationPreviewCanvas.width = canvasWidth * 4;
            animationPreviewCanvas.height = canvasHeight * 4;
            animationPreviewCtx.imageSmoothingEnabled = false;
        }

        function setCurrentTool(tool) {
            if (floatingSelection && (tool !== 'move' && tool !== 'selection' && tool !== 'rotate')) {
                commitFloatingSelection(); 
            }
            if (tool !== 'selection' && tool !== 'move' && tool !== 'rotate' && selectionRect) {
                if (!floatingSelection) cancelActiveSelection(); 
            }

            currentTool = tool;
            updateToolButtons();
            updateSelectionActionsPanel();

            if (tool === 'move' && floatingSelection) {
                canvas.style.cursor = 'move';
            } else if (tool === 'selection') {
                canvas.style.cursor = 'crosshair';
            } else if (tool === 'eyedropper') {
                canvas.style.cursor = 'copy';
            } else {
                canvas.style.cursor = 'crosshair'; 
            }
        }

        function updateToolButtons() {
            document.querySelectorAll('.tool-button').forEach(btn => btn.classList.remove('active'));
            if (currentTool === 'pencil') pencilToolButton.classList.add('active');
            if (currentTool === 'eraser') eraserToolButton.classList.add('active');
            if (currentTool === 'fill') fillToolButton.classList.add('active');
            if (currentTool === 'eyedropper') eyedropperToolButton.classList.add('active');
            if (currentTool === 'selection') selectionToolButton.classList.add('active');
            if (currentTool === 'move') moveToolButton.classList.add('active');
        }
        
        function updateSelectionActionsPanel() {
            if (floatingSelection || selectionRect) {
                selectionActionsPanel.classList.remove('hidden');
            } else {
                selectionActionsPanel.classList.add('hidden');
            }
        }

        function handleCanvasMouseDown(e) {
            if (currentFrameIndex === -1 || currentLayerIndex === -1) return;
            const activeLayer = frames[currentFrameIndex].layers[currentLayerIndex];
            if (!activeLayer || !activeLayer.visible) return;

            const rect = canvas.getBoundingClientRect();
            const x = Math.floor((e.clientX - rect.left) / pixelSize);
            const y = Math.floor((e.clientY - rect.top) / pixelSize);

            isDrawing = true; 

            if (currentTool === 'selection') {
                if (floatingSelection) commitFloatingSelection(); 
                isSelecting = true;
                selectionRect = { x, y, width: 0, height: 0 };
                selectedImageData = null; 
                floatingSelection = null;
                redrawCurrentFrameComposed(); 
            } else if (currentTool === 'move') {
                if (floatingSelection && x >= floatingSelection.x && x < floatingSelection.x + floatingSelection.imageData.width &&
                    y >= floatingSelection.y && y < floatingSelection.y + floatingSelection.imageData.height) {
                    selectionDragStart = { mouseX: x, mouseY: y, selectionX: floatingSelection.x, selectionY: floatingSelection.y };
                    canvas.style.cursor = 'grabbing';
                } else {
                    if (floatingSelection) commitFloatingSelection();
                    isDrawing = false; 
                }
            } else if (currentTool === 'eyedropper') {
                pickColorFromComposed(x, y);
                isDrawing = false; 
            } else if (currentTool === 'fill') {
                if (floatingSelection) commitFloatingSelection();
                floodFillActiveLayer(x, y, hexToRgbWithAlpha(currentColor));
                saveLayerHistory();
                redrawCurrentFrameComposed();
                updateFrameThumbnail(currentFrameIndex);
                isDrawing = false; 
            } else { 
                if (floatingSelection) commitFloatingSelection();
                drawOnActiveLayer(e); 
            }
            updateSelectionActionsPanel();
        }

        function handleCanvasMouseMove(e) {
            if (!isDrawing) return;
            if (currentFrameIndex === -1 || currentLayerIndex === -1) return;

            const rect = canvas.getBoundingClientRect();
            const mouseX = Math.floor((e.clientX - rect.left) / pixelSize);
            const mouseY = Math.floor((e.clientY - rect.top) / pixelSize);

            if (currentTool === 'selection' && isSelecting && selectionRect) {
                selectionRect.width = mouseX - selectionRect.x;
                selectionRect.height = mouseY - selectionRect.y;
                drawSelectionOutline(); 
            } else if (currentTool === 'move' && selectionDragStart && floatingSelection) {
                const deltaX = mouseX - selectionDragStart.mouseX;
                const deltaY = mouseY - selectionDragStart.mouseY;
                floatingSelection.x = selectionDragStart.selectionX + deltaX;
                floatingSelection.y = selectionDragStart.selectionY + deltaY;
                redrawCurrentFrameComposed();
            } else if (currentTool !== 'eyedropper' && currentTool !== 'fill' && currentTool !== 'selection' && currentTool !== 'move') {
                drawOnActiveLayer(e);
            }
        }

        function handleCanvasMouseUp(e) {
            if (!isDrawing) return;
            isDrawing = false;
            const rect = canvas.getBoundingClientRect(); // Definir rect aqui para uso geral

            if (currentTool === 'selection' && isSelecting) {
                isSelecting = false;
                if (selectionRect.width !== 0 || selectionRect.height !== 0) { 
                    if (selectionRect.width < 0) {
                        selectionRect.x += selectionRect.width;
                        selectionRect.width *= -1;
                    }
                    if (selectionRect.height < 0) {
                        selectionRect.y += selectionRect.height;
                        selectionRect.height *= -1;
                    }
                    selectionRect.x = Math.max(0, Math.min(canvasWidth -1, selectionRect.x));
                    selectionRect.y = Math.max(0, Math.min(canvasHeight -1, selectionRect.y));
                    selectionRect.width = Math.max(0, Math.min(canvasWidth - selectionRect.x, selectionRect.width)); 
                    selectionRect.height = Math.max(0, Math.min(canvasHeight - selectionRect.y, selectionRect.height)); 
                    
                    // Verifica se foi apenas um clique (sem arrastar)
                    const clickX = Math.floor((e.clientX - rect.left) / pixelSize);
                    const clickY = Math.floor((e.clientY - rect.top) / pixelSize);

                    if (selectionRect.width === 0 && selectionRect.height === 0 && clickX === selectionRect.x && clickY === selectionRect.y){
                         cancelActiveSelection();
                    } else if (selectionRect.width >= 0 && selectionRect.height >= 0) { 
                         if (selectionRect.width === 0 && selectionRect.height === 0) { 
                            cancelActiveSelection();
                        } else {
                            captureSelection(); 
                        }
                    } else {
                        cancelActiveSelection(); 
                    }
                } else {
                     cancelActiveSelection(); 
                }
                drawSelectionOutline(); 
            } else if (currentTool === 'move') {
                selectionDragStart = null;
                canvas.style.cursor = 'move'; 
            } else if (currentTool !== 'eyedropper' && currentTool !== 'fill') {
                saveLayerHistory();
                redrawCurrentFrameComposed(); 
                updateFrameThumbnail(currentFrameIndex);
            }
            updateSelectionActionsPanel();
        }

        function handleCanvasMouseLeave(e) {
            if (isDrawing) {
                 if (currentTool === 'selection' && isSelecting) {
                    handleCanvasMouseUp(e); 
                } else if (currentTool === 'move' && selectionDragStart) {
                    selectionDragStart = null;
                    canvas.style.cursor = 'move';
                } else if (currentTool !== 'eyedropper' && currentTool !== 'fill') {
                    isDrawing = false;
                    saveLayerHistory();
                    redrawCurrentFrameComposed();
                    updateFrameThumbnail(currentFrameIndex);
                }
            }
        }

        function captureSelection() {
            if (!selectionRect || (selectionRect.width === 0 && selectionRect.height === 0)) { 
                 if (selectionRect.width === 0 && selectionRect.height === 0) { 
                    cancelActiveSelection();
                    return;
                }
            }

            const activeLayer = frames[currentFrameIndex].layers[currentLayerIndex];
            if (!activeLayer) {
                cancelActiveSelection();
                return;
            }

            const sWidth = selectionRect.width === 0 ? 1 : selectionRect.width; 
            const sHeight = selectionRect.height === 0 ? 1 : selectionRect.height;

            const tempCanvas = createCanvasFromImageData(activeLayer.imageData);
            selectedImageData = tempCanvas.getContext('2d', { willReadFrequently: true })
                                .getImageData(selectionRect.x, selectionRect.y, sWidth, sHeight);

            floatingSelection = {
                imageData: new ImageData(new Uint8ClampedArray(selectedImageData.data), selectedImageData.width, selectedImageData.height),
                x: selectionRect.x,
                y: selectionRect.y
            };

            const layerCtx = createCanvasFromImageData(activeLayer.imageData).getContext('2d');
            layerCtx.clearRect(selectionRect.x, selectionRect.y, sWidth, sHeight);
            activeLayer.imageData = layerCtx.getImageData(0, 0, canvasWidth, canvasHeight);
            
            redrawCurrentFrameComposed();
            updateSelectionActionsPanel();
            setCurrentTool('move'); 
        }

        function commitFloatingSelection() {
            if (!floatingSelection || currentFrameIndex === -1 || currentLayerIndex === -1) return;

            const activeLayer = frames[currentFrameIndex].layers[currentLayerIndex];
            const layerCtx = createCanvasFromImageData(activeLayer.imageData).getContext('2d');
            
            const floatingCanvas = createCanvasFromImageData(floatingSelection.imageData);
            layerCtx.drawImage(floatingCanvas, floatingSelection.x, floatingSelection.y);
            
            activeLayer.imageData = layerCtx.getImageData(0, 0, canvasWidth, canvasHeight);

            saveLayerHistory(); 
            
            cancelActiveSelection(false); 
            redrawCurrentFrameComposed();
            updateFrameThumbnail(currentFrameIndex);
        }

        function cancelActiveSelection(doRedraw = true) {
            selectionRect = null;
            isSelecting = false;
            selectedImageData = null;
            floatingSelection = null;
            selectionDragStart = null;
            
            if (doRedraw) {
                redrawCurrentFrameComposed(); 
            } else {
                selectionCtx.clearRect(0, 0, selectionCanvas.width, selectionCanvas.height); 
            }
            updateSelectionActionsPanel();
            if (currentTool === 'move' || currentTool === 'selection') {
                 canvas.style.cursor = 'crosshair'; 
            }
        }
        
        function rotateFloatingSelection(degrees) {
            if (!floatingSelection || !floatingSelection.imageData) return;

            const { imageData, x, y } = floatingSelection;
            const w = imageData.width;
            const h = imageData.height;

            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');

            if (degrees === 90 || degrees === -90) {
                tempCanvas.width = h;
                tempCanvas.height = w;
            } else { 
                tempCanvas.width = w;
                tempCanvas.height = h;
            }
            
            tempCtx.translate(tempCanvas.width / 2, tempCanvas.height / 2);
            tempCtx.rotate(degrees * Math.PI / 180);
            
            const sourceCanvas = createCanvasFromImageData(imageData);

            if (degrees === 90 || degrees === -90) {
                 tempCtx.drawImage(sourceCanvas, -w / 2, -h / 2);
            } else {
                 tempCtx.drawImage(sourceCanvas, -w / 2, -h / 2);
            }
           
            const rotatedImageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);

            const newX = x + (w - h) / 2;
            const newY = y + (h - w) / 2;

            floatingSelection.imageData = rotatedImageData;
            floatingSelection.x = Math.round(newX); 
            floatingSelection.y = Math.round(newY);

            redrawCurrentFrameComposed();
            updateSelectionActionsPanel(); 
        }

        function drawOnActiveLayer(e) {
            if (currentFrameIndex === -1 || currentLayerIndex === -1) return;
            const activeLayer = frames[currentFrameIndex].layers[currentLayerIndex];
            if (!activeLayer || !activeLayer.visible) return;

            const rect = canvas.getBoundingClientRect();
            const x = Math.floor((e.clientX - rect.left) / pixelSize);
            const y = Math.floor((e.clientY - rect.top) / pixelSize);

            if (x < 0 || x >= canvasWidth || y < 0 || y >= canvasHeight) return;

            const colorRgbA = (currentTool === 'eraser') 
                ? { r: 0, g: 0, b: 0, a: 0 } 
                : hexToRgbWithAlpha(currentColor); 

            updateLayerPixel(activeLayer.imageData, x, y, colorRgbA);
            redrawCurrentFrameComposed(); 
        }
        
        function updateLayerPixel(imageData, x, y, colorRgba) {
            const index = (y * imageData.width + x) * 4;
            imageData.data[index] = colorRgba.r;
            imageData.data[index + 1] = colorRgba.g;
            imageData.data[index + 2] = colorRgba.b;
            imageData.data[index + 3] = colorRgba.a;
        }

        function hexToRgbWithAlpha(hex, alpha = 255) { 
            let r = 0, g = 0, b = 0;
            if (hex.length == 4) { 
                r = parseInt(hex[1] + hex[1], 16);
                g = parseInt(hex[2] + hex[2], 16);
                b = parseInt(hex[3] + hex[3], 16);
            } else if (hex.length == 7) { 
                r = parseInt(hex.slice(1, 3), 16);
                g = parseInt(hex.slice(3, 5), 16);
                b = parseInt(hex.slice(5, 7), 16);
            }
            return { r, g, b, a: alpha };
        }
        
        function rgbToHex(r, g, b) {
            return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).toUpperCase();
        }

        function pickColorFromComposed(canvasLogicX, canvasLogicY) {
            if (canvasLogicX < 0 || canvasLogicX >= canvasWidth || canvasLogicY < 0 || canvasLogicY >= canvasHeight) return;
            const tempRenderCanvas = document.createElement('canvas');
            tempRenderCanvas.width = canvasWidth;
            tempRenderCanvas.height = canvasHeight;
            const tempRenderCtx = tempRenderCanvas.getContext('2d');
            tempRenderCtx.imageSmoothingEnabled = false;

            if (currentFrameIndex !== -1 && frames[currentFrameIndex]) {
                frames[currentFrameIndex].layers.forEach(layer => {
                    if (layer.visible && layer.imageData) {
                        tempRenderCtx.drawImage(createCanvasFromImageData(layer.imageData), 0, 0);
                    }
                });
                if (floatingSelection && floatingSelection.imageData) {
                    const selImgCanvas = createCanvasFromImageData(floatingSelection.imageData);
                    tempRenderCtx.drawImage(selImgCanvas, floatingSelection.x, floatingSelection.y);
                }
            }
            
            const pixelData = tempRenderCtx.getImageData(canvasLogicX, canvasLogicY, 1, 1).data;
            currentColor = rgbToHex(pixelData[0], pixelData[1], pixelData[2]);
            colorPicker.value = currentColor;
            setCurrentTool('pencil');
        }

        function floodFillActiveLayer(startX, startY, fillColorRgbA) {
            if (currentFrameIndex === -1 || currentLayerIndex === -1) return;
            const activeLayer = frames[currentFrameIndex].layers[currentLayerIndex];
            if (!activeLayer.visible) return;

            const { imageData } = activeLayer;
            const { width, height, data } = imageData;
            const targetColorIndex = (startY * width + startX) * 4;
            const targetR = data[targetColorIndex];
            const targetG = data[targetColorIndex + 1];
            const targetB = data[targetColorIndex + 2];
            const targetA = data[targetColorIndex + 3];

            if (targetR === fillColorRgbA.r && targetG === fillColorRgbA.g && targetB === fillColorRgbA.b && targetA === fillColorRgbA.a) {
                return; 
            }
            const queue = [[startX, startY]];
            const visited = new Set(); 
            
            while (queue.length > 0) {
                const [x, y] = queue.shift();
                const coordKey = `${x},${y}`;
                if (x < 0 || x >= width || y < 0 || y >= height || visited.has(coordKey)) continue;
                visited.add(coordKey);
                const currentIndex = (y * width + x) * 4;
                if (data[currentIndex] === targetR &&
                    data[currentIndex + 1] === targetG &&
                    data[currentIndex + 2] === targetB &&
                    data[currentIndex + 3] === targetA) {
                    data[currentIndex] = fillColorRgbA.r;
                    data[currentIndex + 1] = fillColorRgbA.g;
                    data[currentIndex + 2] = fillColorRgbA.b;
                    data[currentIndex + 3] = fillColorRgbA.a;
                    queue.push([x + 1, y]); queue.push([x - 1, y]); queue.push([x, y + 1]); queue.push([x, y - 1]);
                }
            }
        }

        function saveLayerHistory() {
            if (currentFrameIndex === -1 || currentLayerIndex === -1) return;
            const activeLayer = frames[currentFrameIndex].layers[currentLayerIndex];
            if (!activeLayer || !activeLayer.imageData) return; 
            const clonedData = new Uint8ClampedArray(activeLayer.imageData.data);
            const historyEntry = new ImageData(clonedData, activeLayer.imageData.width, activeLayer.imageData.height);
            if (!activeLayer.history) activeLayer.history = [];
            activeLayer.history.push(historyEntry);
            if (activeLayer.history.length > 20) activeLayer.history.shift();
        }

        function undoLastActionOnLayer() {
            if (currentFrameIndex === -1 || currentLayerIndex === -1) {
                showModal("Nenhuma camada ativa para desfazer."); return;
            }
            const activeLayer = frames[currentFrameIndex].layers[currentLayerIndex];
            if (!activeLayer || !activeLayer.history || activeLayer.history.length <= 1) {
                 showModal("Nada para desfazer nesta camada."); return;
            }
            if (floatingSelection) {
                cancelActiveSelection(false); 
            }

            activeLayer.history.pop(); 
            const previousState = activeLayer.history[activeLayer.history.length - 1];
            if (previousState) {
                const clonedData = new Uint8ClampedArray(previousState.data);
                activeLayer.imageData = new ImageData(clonedData, previousState.width, previousState.height);
                redrawCurrentFrameComposed();
                updateFrameThumbnail(currentFrameIndex);
            }
        }

        function exportImage(format) {
            if (currentFrameIndex === -1 || !frames[currentFrameIndex]) {
                showModal("Nenhum frame selecionado para exportar."); return;
            }
            if (floatingSelection) commitFloatingSelection(); 

            const zoomFactor = parseInt(exportZoomInput.value) || 1;
            const exportWidth = canvasWidth * zoomFactor;
            const exportHeight = canvasHeight * zoomFactor;
            const exportCanvas = document.createElement('canvas');
            exportCanvas.width = exportWidth;
            exportCanvas.height = exportHeight;
            const exportCtx = exportCanvas.getContext('2d');
            exportCtx.imageSmoothingEnabled = false;
            const tempCompositeCanvas = document.createElement('canvas');
            tempCompositeCanvas.width = canvasWidth;
            tempCompositeCanvas.height = canvasHeight;
            const tempCompositeCtx = tempCompositeCanvas.getContext('2d');
            tempCompositeCtx.imageSmoothingEnabled = false;

            frames[currentFrameIndex].layers.forEach(layer => {
                if (layer.visible && layer.imageData) {
                    tempCompositeCtx.drawImage(createCanvasFromImageData(layer.imageData), 0, 0);
                }
            });
            if (format === 'jpeg') {
                const finalExportCanvas = document.createElement('canvas');
                finalExportCanvas.width = exportWidth;
                finalExportCanvas.height = exportHeight;
                const finalExportCtx = finalExportCanvas.getContext('2d');
                finalExportCtx.fillStyle = 'white';
                finalExportCtx.fillRect(0, 0, exportWidth, exportHeight);
                finalExportCtx.imageSmoothingEnabled = false;
                finalExportCtx.drawImage(tempCompositeCanvas, 0, 0, canvasWidth, canvasHeight, 0, 0, exportWidth, exportHeight);
                exportCanvas.getContext('2d').drawImage(finalExportCanvas,0,0);
            } else {
                 exportCtx.drawImage(tempCompositeCanvas, 0, 0, canvasWidth, canvasHeight, 0, 0, exportWidth, exportHeight);
            }
            const dataURL = exportCanvas.toDataURL(`image/${format}`, format === 'jpeg' ? 0.9 : undefined);
            const link = document.createElement('a');
            link.download = `pixel_art_frame_${currentFrameIndex + 1}_${Date.now()}.${format}`;
            link.href = dataURL;
            link.click();
            showModal(`Imagem exportada como ${format.toUpperCase()} com zoom ${zoomFactor}x.`);
        }

        function addNewFrame() {
            if (floatingSelection) commitFloatingSelection();
            const newFrame = {
                layers: [createEmptyLayerData()], 
                frameHistory: [] 
            };
            frames.push(newFrame);
            currentFrameIndex = frames.length - 1;
            currentLayerIndex = 0; 
            setActiveFrameUI(currentFrameIndex);
            renderLayerList();
            setActiveLayerUI(currentLayerIndex);
            redrawCurrentFrameComposed();
            if (frames[currentFrameIndex].layers[0]) saveLayerHistory(); 
            renderFrameThumbnails();
        }
        
        function duplicateActiveFrame() {
            if (currentFrameIndex === -1) {
                showModal("Nenhum frame ativo para duplicar.");
                return;
            }
            if (floatingSelection) commitFloatingSelection();

            const originalFrame = frames[currentFrameIndex];
            const newFrame = {
                layers: [],
                frameHistory: [] 
            };

            originalFrame.layers.forEach(originalLayer => {
                const newLayerData = new Uint8ClampedArray(originalLayer.imageData.data);
                const newImageData = new ImageData(newLayerData, originalLayer.imageData.width, originalLayer.imageData.height);
                newFrame.layers.push({
                    imageData: newImageData,
                    name: originalLayer.name, 
                    visible: originalLayer.visible,
                    history: [newImageData] 
                });
            });

            frames.splice(currentFrameIndex + 1, 0, newFrame);
            currentFrameIndex++; 
            currentLayerIndex = newFrame.layers.length > 0 ? 0 : -1;

            setActiveFrameUI(currentFrameIndex);
            renderLayerList();
            setActiveLayerUI(currentLayerIndex);
            redrawCurrentFrameComposed();
            renderFrameThumbnails();
            showModal(`Frame ${currentFrameIndex} duplicado.`);
        }


        function removeCurrentFrame() {
            if (frames.length <= 1) { showModal("Não é possível remover o único frame."); return; }
            if (currentFrameIndex === -1) { showModal("Nenhum frame selecionado para remover."); return; }
            if (floatingSelection) commitFloatingSelection();

            frames.splice(currentFrameIndex, 1);
            if (currentFrameIndex >= frames.length) currentFrameIndex = frames.length - 1;
            
            if (currentFrameIndex !== -1) {
                currentLayerIndex = frames[currentFrameIndex].layers.length > 0 ? 0 : -1; 
                setActiveFrameUI(currentFrameIndex);
                renderLayerList();
                setActiveLayerUI(currentLayerIndex);
            } else {
                currentLayerIndex = -1;
                layersContainer.innerHTML = ''; 
            }
            redrawCurrentFrameComposed();
            renderFrameThumbnails();
        }

        function renderFrameThumbnails() {
            framesContainer.innerHTML = '';
            frames.forEach((frame, index) => {
                const thumbCanvas = document.createElement('canvas');
                thumbCanvas.width = 64; thumbCanvas.height = 64;
                thumbCanvas.className = 'frame-thumbnail';
                if (index === currentFrameIndex) thumbCanvas.classList.add('active-frame');
                const thumbCtx = thumbCanvas.getContext('2d');
                thumbCtx.imageSmoothingEnabled = false;
                const tempCompositeCanvas = document.createElement('canvas');
                tempCompositeCanvas.width = canvasWidth; tempCompositeCanvas.height = canvasHeight;
                const tempCompositeCtx = tempCompositeCanvas.getContext('2d');
                tempCompositeCtx.imageSmoothingEnabled = false;
                frame.layers.forEach(layer => {
                    if (layer.visible && layer.imageData) {
                         tempCompositeCtx.drawImage(createCanvasFromImageData(layer.imageData), 0, 0);
                    }
                });
                thumbCtx.drawImage(tempCompositeCanvas, 0, 0, canvasWidth, canvasHeight, 0, 0, 64, 64);
                thumbCanvas.addEventListener('click', () => {
                    if (floatingSelection) commitFloatingSelection();
                    currentFrameIndex = index;
                    currentLayerIndex = frames[index].layers.length > 0 ? 0 : -1; 
                    setActiveFrameUI(index);
                    renderLayerList();
                    setActiveLayerUI(currentLayerIndex);
                    redrawCurrentFrameComposed();
                });
                framesContainer.appendChild(thumbCanvas);
            });
        }
        
        function updateAllFrameThumbnails() {
            frames.forEach((_, index) => updateFrameThumbnail(index));
            renderFrameThumbnails(); 
        }

        function updateFrameThumbnail(index) {
            if (index < 0 || index >= frames.length || !framesContainer.children[index]) return;
            const thumbCanvas = framesContainer.children[index];
            if (!(thumbCanvas instanceof HTMLCanvasElement)) return;
            const thumbCtx = thumbCanvas.getContext('2d');
            thumbCtx.imageSmoothingEnabled = false;
            thumbCtx.clearRect(0,0, thumbCanvas.width, thumbCanvas.height);
            const frame = frames[index];
            if (frame) {
                const tempCompositeCanvas = document.createElement('canvas');
                tempCompositeCanvas.width = canvasWidth; tempCompositeCanvas.height = canvasHeight;
                const tempCompositeCtx = tempCompositeCanvas.getContext('2d');
                tempCompositeCtx.imageSmoothingEnabled = false;
                frame.layers.forEach(layer => {
                    if (layer.visible && layer.imageData) {
                        tempCompositeCtx.drawImage(createCanvasFromImageData(layer.imageData), 0, 0);
                    }
                });
                thumbCtx.drawImage(tempCompositeCanvas, 0, 0, canvasWidth, canvasHeight, 0, 0, thumbCanvas.width, thumbCanvas.height);
            }
        }

        function setActiveFrameUI(index) {
            currentFrameIndex = index; 
            document.querySelectorAll('.frame-thumbnail').forEach((thumb, i) => {
                thumb.classList.toggle('active-frame', i === index);
            });
        }

        function renderLayerList() {
            layersContainer.innerHTML = '';
            if (currentFrameIndex === -1 || !frames[currentFrameIndex]) {
                layersContainer.innerHTML = '<p class="text-xs text-gray-400 text-center">Nenhum frame selecionado</p>'; return;
            }
            const currentFrameLayers = frames[currentFrameIndex].layers;
            if (currentFrameLayers.length === 0) {
                 layersContainer.innerHTML = '<p class="text-xs text-gray-400 text-center">Nenhuma camada neste frame</p>'; return;
            }
            for (let i = currentFrameLayers.length - 1; i >= 0; i--) { 
                const layer = currentFrameLayers[i];
                const layerItem = document.createElement('div');
                layerItem.className = 'layer-item';
                if (i === currentLayerIndex) layerItem.classList.add('active-layer');
                layerItem.dataset.layerIndex = i;
                const layerNameSpan = document.createElement('span');
                layerNameSpan.className = 'layer-name truncate';
                layerNameSpan.textContent = layer.name;
                layerNameSpan.title = layer.name; 
                layerNameSpan.ondblclick = () => renameLayer(i);
                const visibilityButton = document.createElement('button');
                visibilityButton.innerHTML = `<i class="fas ${layer.visible ? 'fa-eye' : 'fa-eye-slash'}"></i>`;
                visibilityButton.title = layer.visible ? "Ocultar Camada" : "Mostrar Camada";
                visibilityButton.onclick = (e) => { e.stopPropagation(); toggleLayerVisibility(i); };
                const layerActions = document.createElement('div');
                layerActions.className = 'layer-actions';
                layerActions.appendChild(visibilityButton);
                layerItem.appendChild(layerActions); 
                layerItem.appendChild(layerNameSpan); 
                layerItem.addEventListener('click', () => {
                    if (floatingSelection) commitFloatingSelection();
                    currentLayerIndex = i;
                    setActiveLayerUI(i);
                });
                layersContainer.appendChild(layerItem);
            }
        }

        function renameLayer(layerIndex) {
            if (currentFrameIndex === -1) return;
            const layer = frames[currentFrameIndex].layers[layerIndex];
            if (!layer) return;
            const newName = prompt("Digite o novo nome para a camada:", layer.name);
            if (newName && newName.trim() !== "") {
                layer.name = newName.trim();
                renderLayerList(); 
            }
        }

        function setActiveLayerUI(index) {
            currentLayerIndex = index; 
            document.querySelectorAll('#layersContainer .layer-item').forEach(item => {
                item.classList.toggle('active-layer', parseInt(item.dataset.layerIndex) === index);
            });
        }

        function addNewLayerToCurrentFrame() {
            if (currentFrameIndex === -1) { showModal("Selecione ou crie um frame primeiro."); return; }
            if (floatingSelection) commitFloatingSelection();
            const newLayer = createEmptyLayerData(); 
            
            const insertAtIndex = (currentLayerIndex === -1 || frames[currentFrameIndex].layers.length === 0) 
                                ? 0 
                                : currentLayerIndex; 

            frames[currentFrameIndex].layers.splice(insertAtIndex, 0, newLayer);
            currentLayerIndex = insertAtIndex; 
            saveLayerHistory(); 
            renderLayerList();
            setActiveLayerUI(currentLayerIndex);
            redrawCurrentFrameComposed(); 
        }
        
        function duplicateActiveLayer() {
            if (currentFrameIndex === -1 || currentLayerIndex === -1) {
                showModal("Nenhuma camada ativa para duplicar.");
                return;
            }
            if (floatingSelection) commitFloatingSelection();

            const originalLayer = frames[currentFrameIndex].layers[currentLayerIndex];
            const newLayerData = new Uint8ClampedArray(originalLayer.imageData.data); 
            const newImageData = new ImageData(newLayerData, originalLayer.imageData.width, originalLayer.imageData.height);

            const duplicatedLayer = {
                imageData: newImageData,
                name: `${originalLayer.name} (Cópia)`,
                visible: originalLayer.visible,
                history: [newImageData] 
            };

            frames[currentFrameIndex].layers.splice(currentLayerIndex, 0, duplicatedLayer);
            
            renderLayerList();
            setActiveLayerUI(currentLayerIndex); 
            redrawCurrentFrameComposed();
            showModal(`Camada "${originalLayer.name}" duplicada.`);
        }


        function removeActiveLayer() {
            if (currentFrameIndex === -1 || currentLayerIndex === -1) { showModal("Nenhuma camada selecionada para remover."); return; }
            const currentFrame = frames[currentFrameIndex];
            if (currentFrame.layers.length <= 1) { showModal("Não é possível remover a única camada do frame."); return; }
            if (floatingSelection) commitFloatingSelection();

            showModal("Tem certeza que deseja remover a camada ativa?", true, () => {
                currentFrame.layers.splice(currentLayerIndex, 1);
                if (currentLayerIndex >= currentFrame.layers.length) {
                    currentLayerIndex = currentFrame.layers.length - 1;
                }
                if (currentFrame.layers.length > 0 && currentLayerIndex < 0) {
                    currentLayerIndex = 0;
                } else if (currentFrame.layers.length === 0) {
                    currentLayerIndex = -1; 
                }


                renderLayerList();
                setActiveLayerUI(currentLayerIndex); 
                redrawCurrentFrameComposed();
                updateFrameThumbnail(currentFrameIndex);
            });
        }

        function toggleLayerVisibility(layerIndex) {
            if (currentFrameIndex === -1) return;
            const layer = frames[currentFrameIndex].layers[layerIndex];
            if (layer) {
                if (floatingSelection && currentLayerIndex === layerIndex) commitFloatingSelection(); 
                layer.visible = !layer.visible;
                renderLayerList(); 
                redrawCurrentFrameComposed();
                updateFrameThumbnail(currentFrameIndex);
            }
        }
        
        function moveActiveLayer(direction) {
            if (currentFrameIndex === -1 || currentLayerIndex === -1) return;
            if (floatingSelection) commitFloatingSelection();
            const layers = frames[currentFrameIndex].layers;
            const targetIndex = currentLayerIndex;

            if (direction === 'up') { 
                if (targetIndex > 0) {
                    [layers[targetIndex], layers[targetIndex - 1]] = [layers[targetIndex - 1], layers[targetIndex]];
                    currentLayerIndex = targetIndex - 1;
                }
            } else if (direction === 'down') { 
                 if (targetIndex < layers.length - 1) {
                    [layers[targetIndex], layers[targetIndex + 1]] = [layers[targetIndex + 1], layers[targetIndex]];
                    currentLayerIndex = targetIndex + 1;
                }
            }
            renderLayerList();
            setActiveLayerUI(currentLayerIndex);
            redrawCurrentFrameComposed();
            updateFrameThumbnail(currentFrameIndex);
        }

        function toggleAnimation() {
            if (isPlaying) {
                stopAnimationLoop();
            } else {
                if (frames.length === 0) { showModal("Adicione frames para iniciar a animação."); return; }
                if (floatingSelection) commitFloatingSelection();
                startAnimationLoop();
            }
        }

        function startAnimationLoop() {
            isPlaying = true;
            playAnimationButton.textContent = 'Stop';
            playAnimationButton.classList.remove('bg-green-500', 'hover:bg-green-600');
            playAnimationButton.classList.add('bg-orange-500', 'hover:bg-orange-600');

            let animFrameIndex = 0;
            const fps = parseInt(fpsSlider.value);
            animationInterval = setInterval(() => {
                if (frames.length === 0 || !isPlaying) { 
                    stopAnimationLoop(); 
                    return;
                }
                const frame = frames[animFrameIndex];
                animationPreviewCtx.clearRect(0, 0, animationPreviewCanvas.width, animationPreviewCanvas.height);
                if (frame) {
                    const tempCompositeCanvas = document.createElement('canvas');
                    tempCompositeCanvas.width = canvasWidth; tempCompositeCanvas.height = canvasHeight;
                    const tempCompositeCtx = tempCompositeCanvas.getContext('2d');
                    tempCompositeCtx.imageSmoothingEnabled = false;
                    frame.layers.forEach(layer => {
                        if (layer.visible && layer.imageData) {
                            tempCompositeCtx.drawImage(createCanvasFromImageData(layer.imageData), 0, 0);
                        }
                    });
                    animationPreviewCtx.drawImage(tempCompositeCanvas, 0, 0, canvasWidth, canvasHeight, 0, 0, animationPreviewCanvas.width, animationPreviewCanvas.height);
                }
                animFrameIndex = (animFrameIndex + 1) % frames.length;
            }, 1000 / fps);
        }

        function stopAnimationLoop() {
            clearInterval(animationInterval);
            animationInterval = null;
            isPlaying = false; 
            playAnimationButton.textContent = 'Play';
            playAnimationButton.classList.remove('bg-orange-500', 'hover:bg-orange-600');
            playAnimationButton.classList.add('bg-green-500', 'hover:bg-green-600');
        }
        initialize();
    </script>
</body>
</html>
